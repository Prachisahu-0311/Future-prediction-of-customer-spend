# -*- coding: utf-8 -*-
"""Hackathon_deploy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13SWOP55JX2iGYyW-Y9xjrHg7eQVHW1BN
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import matplotlib.pyplot as plt

# =====================================
# LOAD SAVED ARTIFACTS
# =====================================
clf = joblib.load("purchase_model.pkl")          # Stage-1 classifier
reg = joblib.load("spend_model.pkl")             # Stage-2 regressor
features = joblib.load("features.pkl")           # Feature table
actuals = joblib.load("actuals.pkl")             # Actual future spend
feature_columns = joblib.load("feature_columns.pkl")  # TRAINING feature schema

# =====================================
# STREAMLIT CONFIG
# =====================================
st.set_page_config(
    page_title="30-Day Customer Spend Prediction",
    layout="centered"
)

st.title("üìä 30-Day Customer Spend Prediction")
st.write(
    "Predict **expected customer spend for the next 30 days** using historical behavior "
    "via a **two-stage ML model** (purchase probability √ó spend)."
)

# =====================================
# CUSTOMER SELECTION
# =====================================
customer_id = st.selectbox(
    "Select Customer ID",
    options=sorted(features["customer_id"].unique())
)

# =====================================
# PREPARE FEATURE ROW (CRITICAL FIX)
# =====================================
row = features[features["customer_id"] == customer_id]

# Enforce EXACT feature schema used during training
X_row = row.reindex(
    columns=feature_columns,
    fill_value=0
).values

# =====================================
# STAGE 1: PURCHASE PROBABILITY
# =====================================
purchase_prob = clf.predict_proba(X_row)[0, 1]

# =====================================
# STAGE 2: SPEND IF PURCHASE
# =====================================
spend_if_purchase = np.expm1(reg.predict(X_row))[0]
spend_if_purchase = max(0, spend_if_purchase)

# Final expected spend
predicted_spend = purchase_prob * spend_if_purchase

# =====================================
# ACTUAL FUTURE SPEND (IF AVAILABLE)
# =====================================
actual_row = actuals[actuals["customer_id"] == customer_id]

actual_spend = (
    actual_row["future_spend_30d"].values[0]
    if not actual_row.empty
    else 0.0
)

# =====================================
# DISPLAY METRICS
# =====================================
col1, col2, col3 = st.columns(3)

col1.metric("Purchase Probability", f"{purchase_prob:.2f}")
col2.metric("Predicted Spend (¬£)", f"{predicted_spend:.2f}")
col3.metric("Actual Spend (¬£)", f"{actual_spend:.2f}")

# =====================================
# BAR CHART: ACTUAL VS PREDICTED
# =====================================
fig, ax = plt.subplots()
ax.bar(["Actual", "Predicted"], [actual_spend, predicted_spend])
ax.set_ylabel("GBP (¬£)")
ax.set_title(f"Customer {customer_id}: 30-Day Spend Comparison")

st.pyplot(fig)

# =====================================
# EXPLANATION SECTION
# =====================================
st.markdown("""
### üîç How this prediction works
- **Stage 1:** Predicts the probability that a customer will purchase in the next 30 days
- **Stage 2:** Predicts how much the customer would spend *if they purchase*
- **Final Output:** Expected spend = probability √ó conditional spend

This approach handles customers who may not purchase at all and avoids over-prediction.
""")

import joblib

joblib.dump(list(X.columns), "feature_columns.pkl")